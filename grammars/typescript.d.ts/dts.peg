package main

type Parser Peg {
}

start
	<- ModuleDeclaration+ eof

ModuleDeclaration
	<- modifier? 'module' spacing identifier ModuleBody

ModuleBody
	<- block_start 
			WORD+
			#ClassDeclaration* 
			#VariableDeclaration* 
			#FuncDeclaration* 
			#ModuleDeclaration*
	   block_end

ClassDeclaration
	<- modifier? 'class' spacing identifier ExtendClause? ImplementClause? ClassBody

ClassBody
	<- block_start VariableDeclaration* FuncDeclaration* block_end

ExtendClause
	<- 'extends' identifier spacing*

ImplementClause
	<- 'implements' identifier spacing*

VariableDeclaration
	<- modifier? VariableType ';' spacing*

FuncDeclaration
	<- modifier? identifier FuncType ';' spacing*

WORD
	<- modifier/keywords/identifier/separator

block_start
	<- '{' spacing*

block_end
	<- '}' spacing*

paren_start
	<- '(' spacing*

paren_end
	<- ')' spacing*

modifier
	<- ('declare' / 'export') spacing*

Type
	<- ('number' / 'boolean' / 'string' / FuncType / ArrayType) spacing*

FuncType
	<- paren_start 
			VariableType? (ArgumentSeperator VariableType)* 
	   paren_end FuncReturn Type

FuncReturn
	<- '=>' spacing*

ArrayType
	<- identifier '[]'

VariableType
	<- identifier ':' Type

TypeSeperator
	<- ':' spacing*

ArgumentSeperator
	<- ',' spacing*

keywords
	<- ('module' / 'class' / 'interface' / 'extends' / 'implements' / 'private' / 'static'
		/ 'boolean' / 'number' / 'string' / 'void' / 'Function') spacing*

identifier
	<- (!keywords !modifier ([a-z]/[A-Z]/[_]) ([a-z]/[A-Z]/[0-9]/[_?])*) spacing*

separator
	<- [:;(){},\[\].=>]+ spacing*

comment
	<- '//' (!eol .)* eol

spacing         <- [ \r\n\t] / comment
eol             <- '\n'
eof             <- !.
