package main

type Parser Peg {
}

start
	<- ModuleDeclaration+ eof

ModuleDeclaration
	<- modifier? 'module' spacing identifier ModuleBody

ModuleBody
	<- block_start 
			ClassDeclaration*
			VariableDeclaration*
			FuncDeclaration*
	   block_end

ClassDeclaration
	<- modifier? 'class' spacing identifier ExtendClause? ImplementClause? ClassBody

ClassBody
	<- block_start 
			VariableDeclaration* 
			FuncDeclaration* 
	   block_end

ExtendClause
	<- 'extends' identifier spacing*

ImplementClause
	<- 'implements' identifier spacing*

VariableDeclaration
	<- modifier? VariableDifinition ';' spacing*

FuncDeclaration
	<- modifier? identifier FuncType ';' spacing*

WORD
	<- modifier/keywords/identifier/separator

block_start
	<- '{' spacing*

block_end
	<- '}' spacing*

paren_start
	<- '(' spacing*

paren_end
	<- ')' spacing*

modifier
	<- ('declare' / 'export' / 'private' / 'static') spacing*

Type
	<- ('number' / 'boolean' / 'string' / 'Function' / FuncType / ArrayType) spacing*

FuncType
	<- paren_start 
			VariableDifinition? (ArgumentSeperator VariableDifinition)* 
	   paren_end 
	   ( FuncReturn / TypeSeperator) Type

ArrayType
	<- identifier '[]'

VariableDifinition
	<- identifier TypeSeperator Type

TypeSeperator
	<- ':' spacing*

FuncReturn
	<- '=>' spacing*

ArgumentSeperator
	<- ',' spacing*

keywords
	<- ('module' / 'class' / 'interface' / 'extends' / 'implements'
		/ 'boolean' / 'number' / 'string' / 'void') spacing*

identifier
	<- (!keywords !modifier !separator ([a-z]/[A-Z]/[_]) ([a-z]/[A-Z]/[0-9]/[_?.])*) spacing*

separator
	<- [:;(){},\[\].=>]

comment
	<- '//' (!eol .)* eol

spacing         <- [ \r\n\t] / comment
eol             <- '\n'
eof             <- !.
